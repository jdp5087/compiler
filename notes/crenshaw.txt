Notes on Crenshaw's "Let's build a compiler"

#########  Page 13 contains an error: ###############

{
---------------------------------------------------------------
}
{ Parse and Translate an Expression }
procedure Expression;
begin
   Term;
   while Look in ['+', '-'] do begin
      EmitLn('MOVE D0,D1');
      case Look of
      '+': Add;
      '-': Subtract;
      else Expected('Addop');
      end;
   end;
end;
{
--------------------------------------------------------------
}

should be (in Python)


def expression():
    term()
    emitln(movl('%eax','%ebx'))
    while LOOK in ['+', '-']:
        try:
            op = OPS[LOOK]
            op()
        except KeyError:
            expected('Addop')

the emitln before the while loop creates issues:
        movl    $2,%eax
        movl    %eax,%ebx
        movl    $1,%eax
        subl    %eax,%ebx
        negl    %ebx
        movl    %eax,%ebx
        movl    $9,%eax
        addl    %eax,%ebx
        movl    %eax,%ebx
        movl    $1,%eax
        subl    %eax,%ebx
        negl    %ebx
        movl    %eax,%ebx
        movl    $7,%eax
        subl    %eax,%ebx
        negl    %ebx

Notice that this is destroying the value held in %ebx every time through the while loop

        movl    $2,%eax
        movl    %eax,%ebx
        movl    $1,%eax
        subl    %eax,%ebx
        negl    %ebx
        movl    $9,%eax
        addl    %eax,%ebx
        movl    $1,%eax
        subl    %eax,%ebx
        negl    %ebx
        movl    $7,%eax
        subl    %eax,%ebx
        negl    %ebx

This is the correct behavior generated by the Python loop.

Furthermore, the expression 2-1+82-1 does not raise an error, and generates incorrect
assembly instructions (the parser thinks that it is done after it adds 8).

To correct this, the following change to the loop ensure that after every fetch to
term, we have either an addop or \n (meaning that we are done).

def expression():
    def check():
        if LOOK not in OPS.keys() and LOOK != '\n':
            expected('Addop')
    term()
    emitln(movl('%eax','%ebx'))
    check()
    while LOOK in OPS.keys():
        try:
            op = OPS[LOOK]
            op()
            check()
        except BaseException as e:
            expected('Addop')

This is very likely to change very soon, as this error checking assumes 1 digit followed by an op,
always.

###PAGE 23### (Using the 2012 PDF now)

Everything is working, save for a bug where two digits in succession cause the compiler to terminate, while it does not raise an error. I'm not bothering to explicitly call an error, because I'm sure that before long we will be accepting terms() of more than one digit in the near future.

